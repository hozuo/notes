## 传统的认证实现

传统的单体项目用户登录认证使用的是session认证，用户访问服务器会生成独有sessionid，用户登录成功后为用户注册session，在服务器中保存一段时间，存在session则视为用户已登录，但存在一些问题：

1. 使用session中的token作为唯一认证凭证会出现跨站请求伪造攻击风险
2. 前后端分离时token不能自动转发，需要进行跨域处理
3. session默认不支持分布式

为了解决这些问题有以下方法：

1. 服务器返回值中包含一个随机值并保存在session中，客户端收到请求保存在local storge中，每次请求都携带这个随机值在请求头中，由于请求头不会自动发送从而避免请求伪造。
2. 前端可以将token中的sessionid取出放到请求头中、拼接在url路径中或放在表单中
3. 后端可以借助全局缓存，例如redis存储session实现session共享

传统的验证码实现是服务器生成一个随机值生成图片发给前端，前端填写后返回后端使用session校验。前后端分离时仍需要前端转发sessionid，而且不支持分布式，大量存储session会消耗一定的服务器空间。

## 基于JWT的一种用户登录认证实现

### 登录

现基于JWT提出一种实现策略，用户登录请求验证码时在本地生成一个固定格式随机值（例如uuid），和当前时间戳一起发送给后端；后端对字符串格式校验后进行AES加密，将密文的一部分处理后作为验证码，生成图片发送给前端；前端填写验证码后将字符串和验证码一起发送给后端，后端再次进行加密处理进行比对。

### 重放攻击

这种无状态的策略存在重放攻击问题，解决这个问题需要设置验证码有效期（例如3分钟）并设置全局缓存（例如redis）。服务器第一次收到字符串时用当前时间减去时间戳，若当前时间较小说明时间戳是伪造的未来时间，予以回绝；第二次收到验证码时检验时间戳是否是未来时间，是否已过期，成功登录后将字符串放入全局缓存中，每次授权登录时都先查询缓存中是否存在该字符串，若存在则代表是重放，从而避免了重放攻击。缓存存放时间应与验证码有效期相同。

### 分布式session

JWT包含的唯一认证码可以作为key，将信息存在全局缓存中实现分布式session，也就是session共享。JWT的载荷可以存放一些非敏感信息，例如用户的id和用户名，经过私钥签名保证权威性，实现无状态的数据共享。JWT存储在浏览器的local storge中，避免了跨站请求伪造风险。

### 一些问题

JWT存在两个较大问题

1. 已经发布的JWT无法撤销，例如用户修改密码后原先发布的JWT在过期时间内仍然有效，无法手动撤销权限；以前发布的未来某时间生效的JWT仍然可以生效。（废除秘钥对可以撤销全部JWT的有效权）
2. 读取JWT载荷中的信息可能造成数据不一致的情况，例如用户修改用户名后原先发布的JWT用户名不一致。

### 有状态认证

JWT的认证机构可以实现无状态拒绝，有状态认证。收到JWT后先进行公钥认证，认证失败返回；认证成功判断时间是否过期或未到生效时间，失败后返回；在有效期内再查找全局缓存中是否包含JWT的唯一认证码，同时可以取回存储的一些数据。

这样在用户修改密码或用户名后可以在全局缓存中删除用户的JWT缓存，用户将使用新的JWT登录。该认证可以灵活拓展，例如在JWT中发放无状态认证标志（例如管理员权限或低风险账户），认证机构无需查找全局缓存；或者设置某些低风险操作无需验证全局缓存（例如查看用户在JWT中包含的一些资料时）

### 仍然存在的问题

这种分布式session不能存放未登录用户的信息（京东用户未登录也可以将商品加入购物车，但淘宝不能），若有需求考虑使用spring-session将数据存在Redis中，登录后再合并到持久存储中（毕竟京东用户下单总是要登录的）。